import numpy as np

# Example 10x10 array representing default status (0 or 1)
default_array = np.array([
    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
    [0, 0, 1, 1, 0, 1, 0, 1, 1, 0],
    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
    [0, 1, 0, 0, 1, 1, 0, 1, 0, 1],
    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
    [0, 1, 0, 1, 0, 0, 1, 0, 1, 0],
    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
    [0, 1, 0, 1, 0, 1, 0, 0, 1, 0],
    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
    [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
])

# Calculate the number of defaults in the last five years for each property
defaults_last_five_years = np.sum(default_array[:, -5:], axis=1)

# Identify properties with 3 or more defaults in the last five years
uninsurable_properties = np.where(defaults_last_five_years >= 3)[0]

# Create a new array to mark uninsurable properties for the next five years
insurability_array = np.ones_like(default_array, dtype=bool)
for property_index in uninsurable_properties:
    insurability_array[property_index, -5:] = False


import numpy as np

# Example 5x5 array representing default status (0 or 1)
default_array = np.array([
    [1, 0, 1, 0, 1],
    [0, 0, 1, 1, 0],
    [1, 0, 1, 0, 1],
    [0, 1, 0, 0, 1],
    [1, 0, 1, 0, 1]
])

# Create an empty array to store the results
defaults_previous_three_years = np.zeros_like(default_array)

# Iterate over each year
for year in range(default_array.shape[1]):
    # Calculate the number of defaults in the previous three years for each property
    defaults_previous_three_years[:, year] = np.sum(default_array[:, max(0, year-2):year+1], axis=1)

# Create a new array to mark uninsurable properties for the next two years
insurability_array = np.ones_like(default_array, dtype=bool)

# Check if a property has defaulted at least two times in the previous three years at each year
for year in range(defaults_previous_three_years.shape[1]):
    properties_to_uninsure = np.where(defaults_previous_three_years[:, year] >= 2)[0]
    for property_index in properties_to_uninsure:
        insurability_array[property_index, year+1:year+3] = False

# Print the insurability array
print(insurability_array)

##############££££££££££££££££££££££££



import numpy as np

# Example 3D array of size (20, 44, 30) representing default status (0 or 1) for 20 simulations
# with 44 properties over 30 years
default_array = np.random.randint(0, 2, size=(20, 44, 30))

# Create an empty array to store the results
defaults_previous_three_years = np.zeros_like(default_array)

# Iterate over each simulation
for simulation in range(default_array.shape[0]):
    # Iterate over each year
    for year in range(default_array.shape[2]):
        # Calculate the number of defaults in the previous three years for each property
        defaults_previous_three_years[:, :, year] = np.sum(default_array[:, :, max(0, year-2):year+1], axis=2)

# Create a new array to mark uninsurable properties for the next two years
insurability_array = np.ones_like(default_array, dtype=bool)

# Check if a property has defaulted at least two times in the previous three years at each year for each simulation
for simulation in range(defaults_previous_three_years.shape[0]):
    for year in range(defaults_previous_three_years.shape[2]):
        properties_to_uninsure = np.where(defaults_previous_three_years[simulation, :, year] >= 2)[0]
        for property_index in properties_to_uninsure:
            insurability_array[simulation, property_index, year+1:year+3] = False

# Print the insurability array for the first simulation
print(insurability_array[0])
-------

import numpy as np

# Input array representing LTV and DTI ratios
input_array = np.array([
    [0, 0, 1, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0],
    [1, 0, 1, 0, 0],
    [0, 0, 0, 1, 1]
])

# Custom ranges for LTV and DTI ratios
ltv_ranges = [(0, 10), (10, 25), (25, 40), (40, 60), (60, 100)]
dti_ranges = [(0, 15), (15, 30), (30, 45), (45, 60), (60, 100)]

# Read LTV and DTI values from user
ltv_value = float(input("Enter the LTV value: "))
dti_value = float(input("Enter the DTI value: "))

# Find the index of the LTV and DTI bands
ltv_index = -1
dti_index = -1

for i, (start, end) in enumerate(ltv_ranges):
    if ltv_value >= start and ltv_value < end:
        ltv_index = i
        break

for i, (start, end) in enumerate(dti_ranges):
    if dti_value >= start and dti_value < end:
        dti_index = i
        break

# Check if the LTV and DTI values result in default or not
if ltv_index != -1 and dti_index != -1:
    if input_array[ltv_index][dti_index] == 1:
        print("Default occurred for the given LTV and DTI values.")
    else:
        print("No default occurred for the given LTV and DTI values.")
else:
    print("Invalid LTV or DTI value. Please enter values within the valid range.")




